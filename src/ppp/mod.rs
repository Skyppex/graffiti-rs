pub mod receive;
pub mod send;

use std::path::PathBuf;

use futures_util::stream::SplitSink;
use serde::{Deserialize, Serialize};
use tokio::io::{AsyncRead, AsyncWrite};
use tokio_tungstenite::{tungstenite::Message, WebSocketStream};

use crate::csp;

pub type WsWriter<S> = SplitSink<WebSocketStream<S>, Message>;

pub trait AsyncStream: AsyncWrite + AsyncRead + Unpin {}

impl<S: AsyncWrite + AsyncRead + Unpin> AsyncStream for S {}

pub trait Req {
    fn id(&self) -> String;
    fn method(&self) -> String;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request<T> {
    pub id: String,
    pub method: String,
    pub params: Option<T>,
}

impl<T> Req for Request<T> {
    fn id(&self) -> String {
        self.id.clone()
    }

    fn method(&self) -> String {
        self.method.clone()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response<T> {
    pub id: String,
    pub result: Option<T>,
    // pub error: (),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Notification<T> {
    pub method: String,
    pub params: Option<T>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InitializeRequest {
    pub process_id: Option<i32>,
    pub client_info: Option<ClientInfo>,
    pub root_path: Option<String>,
    // #[serde(rename = "initializeOptions")]
    // initialize_options: Option<InitializeOptions>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientInfo {
    pub name: String,
    pub version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InitializeResponse {
    pub host_info: Option<HostInfo>,
    // client id generated by the host.
    // used to identify the client in subsequent messages
    pub client_id: String,
    pub project_dir_name: PathBuf,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HostInfo {
    pub name: String,
    pub version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InitializedNotification {
    pub client_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShutdownRequest;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShutdownResponse;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CursorMovedNotification {
    pub client_id: String,
    pub location: DocumentLocation,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DocumentLocation {
    pub uri: PathBuf,
    pub pos: DocumentPosition,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DocumentPosition {
    pub line: u32,
    pub column: u32,
}

impl DocumentLocation {
    pub fn exists(&self) -> bool {
        self.uri.exists()
    }
}

impl From<csp::DocumentLocation> for DocumentLocation {
    fn from(location: csp::DocumentLocation) -> Self {
        Self {
            uri: location.uri,
            pos: location.pos.into(),
        }
    }
}

impl From<csp::DocumentPosition> for DocumentPosition {
    fn from(pos: csp::DocumentPosition) -> Self {
        Self {
            line: pos.line,
            column: pos.column,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DocumentEditModeNotification {
    pub client_id: String,
    pub mode: DocumentEditMode,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DocumentEditFullNotification {
    pub client_id: String,
    pub mode: DocumentEditMode,
    pub uri: PathBuf,
    pub content: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DocumentEditIncrementalNotification {
    pub client_id: String,
    pub mode: DocumentEditMode,
    pub uri: PathBuf,
    pub start: DocumentPosition,
    pub end: DocumentPosition,
    pub content: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DocumentEditMode {
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "incremental")]
    Incremental,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DirectoriesUploadNotification {
    pub client_id: String,
    pub directories: Vec<Directory>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Directory {
    pub uri: PathBuf,
    #[serde(rename = "type")]
    pub type_: DirectoryType,
    pub content: Vec<u8>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DirectoryType {
    #[serde(rename = "file")]
    File,
    #[serde(rename = "directory")]
    Directory,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct InitialFileNotification {
    pub uri: PathBuf,
}
